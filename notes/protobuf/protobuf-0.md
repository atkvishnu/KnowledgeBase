# Protobufs

Protocol buffers are a `language-neutral`, `platform-neutral extensible mechanism` for `serializing structured data`, like XML and JSON, but smaller and faster.   
The protocol buffer language is a language for specifying the schema for structured data.   
This schema is compiled into language specific bindings.

- You define how you want to structure your data once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.

- Protocol buffers are a combination of the interface definition language(IDL) (created in .proto files), the code that the proto compiler generates to interface with data, language-specific runtime libraries, and the serialization format for data taht is written to a file (or sent across a network connection).


---

[This project](https://github.com/protocolbuffers/protobuf-go) provides both the tool to genrate Go code for the protocol buffer language, and also the runtime implementation to handle serialization of message in Go.   

This project is comprised of two components:
*   Code generator: The [`protoc-gen-go`](https://pkg.go.dev/google.golang.org/protobuf/cmd/protoc-gen-go) tool is a compiler plugin to `protoc`, the protocol buffer compiler. It augments the `protoc` compiler so that it knows how to [generate Go specific code for a given `.proto` file](https://developers.google.com/protocol-buffers/docs/reference/go-generated).

*   Runtime library: The [`protobuf`](https://pkg.go.dev/mod/google.golang.org/protobuf) module contains a set of Go packages that form the runtime implementation of protobufs in Go. This provides the set of interfaces that [define what a message is](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect) and functionality to serialize message in various formats (e.g., [wire](https://pkg.go.dev/google.golang.org/protobuf/proto), [JSON](https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson), and [text](https://pkg.go.dev/google.golang.org/protobuf/encoding/prototext)).

- This project is the second major revision of the Go protocol buffer API implemented by the google.golang.org/protobuf module. The first major version is implemented by the github.com/golang/protobuf module.

***Generated additions: We reserve the right to add new declarations to generated Go packages of .proto files. This includes declared constants, variables, functions, types, fields in structs, and methods on types. This may break attempts at injecting additional code on top of what is generated by protoc-gen-go. Such practice is not supported by this project.***


```go
...
...
...
// 2011/11/03
func Unmarshal(buf []byte, pb_e interface{}) error

// 2012/03/28 - Release of Go 1

// 2012/06/12
func Unmarshal(buf []byte, pb Message) error
```

The change on June 6th, 2012 added a degree of type-safety to Go protobufs by declaring a new interface that all protobuf messages were required to implement:

```go
type Message interface {
   Reset()
   String() string
   ProtoMessage()
}
```

This interface reduced the set of types that can be passed to `proto.Unmarshal` from the universal set of all possible Go types to those with a special ProtoMessage marker method.    
The intention of this change is to limit the protobuf API to only operate on protobuf data types (i.e., protobuf messages).    
For example, there is no sensible operation if a Go channel were passed to the protobuf API as a channel cannot be serialized.   
This interface will prevent that!

- Back in 2012, the only types with this marker were those generated by `protoc-gen-go`. Since `protoc-gen-go` would always generate messages with the proper layout of fields, this was deemed an acceptable and dramatic improvement over `interface{}`.


The increasingly diverse ecosystem of Go types implementing the proto.Message interface led to incompatibilities, which often occurred when:

- `Passing custom proto.Message types to the protobuf APIs`: A concrete message implementation might work with some top-level functions (e.g., proto.Marshal), but cause others (e.g., proto.Equal) to choke and panic. This occurs because the type only had partial support for being an actual message by only implementing the proto.Marshaler interface or having malformed struct field tags that happened to work with one function, but not another.

- `Using Go reflection on any proto.Message types`: A common desire is to write general-purpose code that operates on any protobuf message. For example, a microservice might want to populate a `trace_id` field if it is present in a message. To accomplish this, one would use Go reflection to introspect the message type, and assume it were a pointer to a Go struct with a field named TraceId (as would be commonly produced by protoc-gen-go). If the concrete message type did not match this expectation, it either failed to work or even resulted in a panic. Such was the case for concrete message types that might be backed by a Go map instead of a Go struct.


***Both of these issues are solved by following the idiom that interfaces should describe behavior, not data.***   
This means that the interface itself should provide sufficient functionality through its methods that users can introspect and interact with all aspects of a protobuf message through a principled API.    
This feature is called `protobuf reflection`.    
***Just as how Go reflection provides an API for programmatically interacting with any arbitrary Go value, protobuf reflection provides an API for programmatically interacting with any arbitrary protobuf message.***

Since an interface cannot be extended in a backwards compatible way, this suggested the need for a new major version that defines a new proto.Message interface:

```go
type Message interface {
    ProtoReflect() protoreflect.Message
}
```

The new proto.Message interface contains a single ProtoReflect method that returns a protoreflect.Message, which is a reflective view over a protobuf message. In addition to making a breaking change to the proto.Message interface, we took this opportunity to cleanup the supporting functionality that operate on a proto.Message, split up complicated functionality apart into manageable packages, and to hide implementation details away from the public API.



### Supported Languages: 

- Generated code support: Java, Python, Objective-C, C++.
- New proto3 supports: Kotlin, Dart, Go, Ruby, and C#.

---

```go
message Person {
    optional string name = 1;
    optional int32 id = 2;
    optional string email = 3;
}
```

```go
Person john = Person.newBuilder()
    .setId(1234)
    .setName("John Doe")
    .setEmail("jdoe@example.com")
    .build();
output = new FileOutputStream(args[0]);
john.writeTo(output);
```

```
Person john;
fstream input(argv[1],
    ios::in | ios::binary);
john.ParseFromIstream(&input);
id = john.id();
name = john.name();
email = john.email();
```

---

## [Package Index](https://github.com/protocolbuffers/protobuf-go)

Summary of the packages provided by this module:

- `proto`: Package proto provides functions operating on protobuf messages such as cloning, merging, and checking equality, as well as binary serialization.   
- `encoding/protojson`: Package protojson serializes protobuf messages as JSON.   
- `encoding/prototext`: Package prototext serializes protobuf messages as the text format.   
- `encoding/protowire`: Package protowire parses and formats the low-level raw wire encoding. Most users should use package proto to serialize messages in the wire format.
- `reflect/protoreflect`: Package protoreflect provides interfaces to dynamically manipulate protobuf messages.   
- `reflect/protoregistry`: Package protoregistry provides data structures to register and lookup protobuf descriptor types.
- `reflect/protodesc`: Package protodesc provides functionality for converting descriptorpb.FileDescriptorProto messages to/from the reflective protoreflect.FileDescriptor.
- `reflect/protopath`: Package protopath provides a representation of a sequence of protobuf reflection operations on a message.
- `reflect/protorange`: Package protorange provides functionality to traverse a protobuf message.
- `testing/protocmp`: Package protocmp provides protobuf specific options for the cmp package.
- `testing/protopack`: Package protopack aids manual encoding and decoding of the wire format.
- `testing/prototest`: Package prototest exercises the protobuf reflection implementation for concrete message types.
- `types/dynamicpb`: Package dynamicpb creates protobuf messages at runtime from protobuf descriptors.
- `types/known/anypb`: Package anypb is the generated package for google/protobuf/any.proto.
- `types/known/timestamppb`: Package timestamppb is the generated package for google/protobuf/timestamp.proto.
- `types/known/durationpb`: Package durationpb is the generated package for google/protobuf/duration.proto.
- `types/known/wrapperspb`: Package wrapperspb is the generated package for google/protobuf/wrappers.proto.
- `types/known/structpb`: Package structpb is the generated package for google/protobuf/struct.proto.
- `types/known/fieldmaskpb`: Package fieldmaskpb is the generated package for google/protobuf/field_mask.proto.
- `types/known/apipb`: Package apipb is the generated package for google/protobuf/api.proto.
- `types/known/typepb`: Package typepb is the generated package for google/protobuf/type.proto.
- `types/known/sourcecontextpb`: Package sourcecontextpb is the generated package for google/protobuf/source_context.proto.
- `types/known/emptypb`: Package emptypb is the generated package for google/protobuf/empty.proto.
- `types/descriptorpb`: Package descriptorpb is the generated package for google/protobuf/descriptor.proto.
- `types/pluginpb`: Package pluginpb is the generated package for google/protobuf/compiler/plugin.proto.
- `compiler/protogen`: Package protogen provides support for writing protoc plugins.
- `cmd/protoc-gen-go`: The protoc-gen-go binary is a protoc plugin to generate a Go protocol buffer package.


---


