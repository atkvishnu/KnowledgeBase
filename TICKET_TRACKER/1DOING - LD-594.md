## Panic in JSON encode - Niyo

```
panic: runtime error: index out of range [11] with length 11 [recovered]
panic: runtime error: index out of range [11] with length 11

goroutine 14704 [running]:
encoding/json.(*encodeState).marshal.func1()
/usr/local/go/src/encoding/json/encode.go:328 +0x6e
panic({0x270adc0, 0xc0481690b0})
/usr/local/go/src/runtime/panic.go:1038 +0x215
encoding/json.mapEncoder.encode({0xc04943472c}, 0xc0301ad200, {0x254c6a0, 0xc04fb5dad0, 0x254c6a0}, {0x50, 0x32})
/usr/local/go/src/encoding/json/encode.go:800 +0x706
encoding/json.(*encodeState).reflectValue(0xc0351f33d0, {0x254c6a0, 0xc04fb5dad0, 0x0}, {0x20, 0x69})
/usr/local/go/src/encoding/json/encode.go:360 +0x78
encoding/json.(*encodeState).marshal(0x0, {0x254c6a0, 0xc04fb5dad0}, {0x0, 0x0})
/usr/local/go/src/encoding/json/encode.go:332 +0xfa
encoding/json.Marshal({0x254c6a0, 0xc04fb5dad0})
/usr/local/go/src/encoding/json/encode.go:161 +0x45
bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver.(*LocalReceiverConfigContext).WriteToPartitionDirect(0xc02e924d20, {0x2d0e678, 0xc000060060}, 0xc030503290, 0xc037e0a928)
/go/src/bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver/partition.go:323 +0x734
bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver.(*LocalReceiverConfigContext).CreatePartitionsAndWriteMessageDirect(0xc02e924d20, {0x2d0e678, 0xc000060060}, 0x20, 0xc000d961c8)
/go/src/bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver/local_receiver.go:247 +0x1a5
bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver.(*LocalReceiverConfigContext).ProcessMessageList(0x6d60, 0x466, {0xc037e86b10, 0x466, 0x67e})
/go/src/bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver/local_receiver.go:336 +0x633
bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver.(*LocalReceiverConfigContext).receiverProcessIncomingMessagesHandleList(0xc0353f3e28, 0xc0353f3dbc, {0xc037e86a00, 0x0, 0x20})
/go/src/bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver/local_receiver.go:425 +0x67
bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver.(*LocalReceiverConfigContext).ReceiverProcessIncomingMessages(0xc02e924d20, 0xc02e924ea0, {0x288dc36, 0x4}, 0xc0003c0000)
/go/src/bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver/local_receiver.go:446 +0x3a9
created by bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver.GetFromBrokerQueue.func1
/go/src/bitbucket.org/logiqcloud/flash/broker_receiver/local_receiver/factory.go:76 +0x4c
```

-   ~~ContextLogger() not used, so can not see where this is coming from.~~ error comes from bottom up. Stack trace is always bottom up.
-   ~~Panic happened in `/usr/local/go/src/encoding/json/encode.go:328` according to stack trace, but we switched to sonic after that.~~
-   index went out of range and then it was recovered from panic.
-   Check step by step, read the code, if possible do a size check to avoid index out of range.

maybe

error coming from partition.go:322


```go
/snap/go/9952/src/runtime
‚ùØ grep "index out of range"
symtab.go
1166:		throw("stackmapdata: index out of range")

panic32.go
14:	panicCheck1(getcallerpc(), "index out of range")
18:	panicCheck1(getcallerpc(), "index out of range")

panic.go
88:	panicCheck1(getcallerpc(), "index out of range")
92:	panicCheck1(getcallerpc(), "index out of range")

error.go
145:	boundsIndex:      "index out of range [%x] with length %y",
158:	boundsIndex:      "index out of range [%x]",
```



```go
runtime/error.go

// Many of the following panic entry-points turn into throws when they
// happen in various runtime contexts. These should never happen in
// the runtime, and if they do, they indicate a serious issue and
// should not be caught by user code.
//
// The panic{Index,Slice,divide,shift} functions are called by
// code generated by the compiler for out of bounds index expressions,
// out of bounds slice expressions, division by zero, and shift by negative.
// The panicdiv ide (again), panicoverflow, panicfloat, and panicmem
// functions are called by the signal handler when a signal occurs
// indicating the respective problem.
//
// Since panic{Index,Slice,shift} are never called directly, and
// since the runtime package should never have an out of bounds slice
// or array reference or negative shift, if we see those functions called from the
// runtime package we turn the panic into a throw. That will dump the
// entire runtime stack for easier debugging.
//
// The entry points called by the signal handler will be called from
// runtime.sigpanic, so we can't disallow calls from the runtime to
// these (they always look like they're called from the runtime).
// Hence, for these, we just check for clearly bad runtime conditions.
//
// The panic{Index,Slice} functions are implemented in assembly and tail call
// to the goPanic{Index,Slice} functions below. This is done so we can use
// a space-minimal register calling convention.

// failures in the comparisons for s[x], 0 <= x < y (y == len(s))
func goPanicIndex(x int, y int) {
	panicCheck1(getcallerpc(), "index out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsIndex})
}
func goPanicIndexU(x uint, y int) {
	panicCheck1(getcallerpc(), "index out of range")
	panic(boundsError{x: int64(x), signed: false, y: y, code: boundsIndex})
}

// failures in the comparisons for s[:x], 0 <= x <= y (y == len(s) or cap(s))
func goPanicSliceAlen(x int, y int) {
	panicCheck1(getcallerpc(), "slice bounds out of range")
	panic(boundsError{x: int64(x), signed: true, y: y, code: boundsSliceAlen})
}
```























